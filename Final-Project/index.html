<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Sean Sponsler CS375</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>

	<body>
		<div id="info">
			Plane by <a href="https://sketchfab.com/3d-models/cartoon-plane-f312ec9f87794bdd83630a3bc694d8ea" target="_blank" rel="noopener">antonmoek</a>
			<br><br>
			<span class="colorPicker"><input id="body-color" type="color" value="#ff0000"></input><br/>Body</span>
			<span class="colorPicker"><input id="details-color" type="color" value="#ffffff"></input><br/>Details</span>
			<span class="colorPicker"><input id="glass-color" type="color" value="#ffffff"></input><br/>Glass</span>
		</div>

		<div id="container"></div>

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import Stats from 'three/addons/libs/stats.module.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
			import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

			let camera, scene, renderer;
			let stats;
         let planeRotation = 0;
         let targetRotation = 0;
         const maxAngle = Math.PI / 6; //max 30 degrees of turbulence rotation

			let grid;
			let controls;

         const planeBody = [];
         const propeller = [];

			function init() {

				const container = document.getElementById( 'container' );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( render );
            //
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 0.85;
            renderer.outputEncoding = THREE.sRGBEncoding;

				container.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize );

            //small plugin to show FPS counter in top left
				stats = new Stats();
				container.appendChild( stats.dom );

				//perspective camera

				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( 2.25, 2.4, 5.5 );
            

            //allow camera to orbit around a target
				controls = new OrbitControls( camera, container );
				controls.enableDamping = true;
				controls.maxDistance = 9;
				controls.target.set( 0, 0.5, 0 );
				controls.update();


				scene = new THREE.Scene();
            scene.background = new THREE.Color( 0xbfe3dd );

				new RGBELoader().load( 'textures/equirectangular/sunset.hdr', function (texture) {
               texture.mapping = THREE.EquirectangularReflectionMapping;
               scene.background = texture;
               scene.environment = texture;
            } );

				scene.fog = new THREE.Fog( 0x333333, 10, 15 );
            
				grid = new THREE.GridHelper( 20, 40, 0xffffff, 0xffffff );
				grid.material.opacity = 0.2;
				grid.material.depthWrite = false;
				grid.material.transparent = true;
				//scene.add( grid );
            

				// materials

				const bodyMaterial = new THREE.MeshPhysicalMaterial( {
					color: 0xff0000, metalness: 1.0, roughness: 0.5, clearcoat: 1.0, clearcoatRoughness: 0.03, sheen: 0.5
				} );

				const detailsMaterial = new THREE.MeshStandardMaterial( {
					color: 0xffffff, metalness: 1.0, roughness: 0.5
				} );

				const glassMaterial = new THREE.MeshPhysicalMaterial( {
					color: 0xffffff, metalness: 0.25, roughness: 0, transmission: 1.0
				} );

				const bodyColorInput = document.getElementById( 'body-color' );
				bodyColorInput.addEventListener( 'input', function () {

					bodyMaterial.color.set( this.value );

				} );

				const detailsColorInput = document.getElementById( 'details-color' );
				detailsColorInput.addEventListener( 'input', function () {

					detailsMaterial.color.set( this.value );

				} );

				const glassColorInput = document.getElementById( 'glass-color' );
				glassColorInput.addEventListener( 'input', function () {

					glassMaterial.color.set( this.value );

				} );

				const shadow = new THREE.TextureLoader().load( 'models/ferrari_ao.png' );

				const dracoLoader = new DRACOLoader();
				dracoLoader.setDecoderPath( 'jsm/libs/draco/gltf/' );

				const loader = new GLTFLoader();
				loader.setDRACOLoader( dracoLoader );

				loader.load( 'models/cartoon_plane.glb', function ( gltf ) {
               const planeModel = gltf.scene.children[ 0 ];

               // FINDING OBJECT NAMES: loop through all objects in the scene graph and print their names
               // why do no online glb viewers give this information?
               planeModel.traverse( function( object ) {
                  console.log(object.name);
               });
					planeModel.getObjectByName( 'Body' ).material = bodyMaterial;
               planeBody.push(planeModel.getObjectByName( 'Plane' ));

					planeModel.getObjectByName( 'Plane' ).material = bodyMaterial;
					planeModel.getObjectByName( 'Object_2' ).material = bodyMaterial;
					planeModel.getObjectByName( 'RootNode' ).material = bodyMaterial;
					planeModel.getObjectByName( 'Propeller_1' ).material = detailsMaterial;
               propeller.push(planeModel.getObjectByName( 'Propeller_1' ));
					
					planeModel.getObjectByName( 'Cylinder_1' ).material = detailsMaterial;
               planeModel.getObjectByName( 'Cylinder_1_2' ).material = detailsMaterial;
               planeModel.getObjectByName( 'Cylinder_1_3' ).material = detailsMaterial;
               planeModel.getObjectByName( 'Cylinder_1_3_Body_0' ).material = detailsMaterial;

					planeModel.getObjectByName( 'WheelCarcas' ).material = detailsMaterial;
               planeModel.getObjectByName( 'WheelCarcas_2' ).material = detailsMaterial;
               planeModel.getObjectByName( 'WheelCarcas_3' ).material = detailsMaterial;

					planeModel.getObjectByName( 'Wheel' ).material = detailsMaterial;
					planeModel.getObjectByName( 'Wheel_1' ).material = detailsMaterial;
					planeModel.getObjectByName( 'Wheel_2' ).material = detailsMaterial;
					planeModel.getObjectByName( 'Wheel_3' ).material = detailsMaterial;
					planeModel.getObjectByName( 'Wheel_4' ).material = detailsMaterial;

               planeModel.getObjectByName( 'Wheel_Back' ).material = detailsMaterial;

               planeModel.getObjectByName( 'Air_motor_left' ).material = detailsMaterial;
               planeModel.getObjectByName( 'Air_motor_right' ).material = detailsMaterial;

               planeModel.getObjectByName( 'Cube_Body_0' ).material = bodyMaterial;
					planeModel.getObjectByName( 'Cube' ).material = bodyMaterial;
               planeModel.getObjectByName( 'Cube_1_Body_0' ).material = detailsMaterial;
					planeModel.getObjectByName( 'Cube_1' ).material = detailsMaterial;
               planeModel.getObjectByName( 'Cube_1_2' ).material = detailsMaterial;
               planeModel.getObjectByName( 'Cube_1_2_Body_0' ).material = detailsMaterial;
               planeModel.getObjectByName( 'Cube_1_3' ).material = detailsMaterial;
               planeModel.getObjectByName( 'Cube_1_3_Body_0' ).material = bodyMaterial;
               planeModel.getObjectByName( 'Cube_1_3_Red_0' ).material = detailsMaterial;

					planeModel.getObjectByName( 'Cube_2' ).material = detailsMaterial;
               planeModel.getObjectByName( 'Cube_2_Body_0' ).material = detailsMaterial;
               planeModel.getObjectByName( 'Cube_2_2' ).material = detailsMaterial;
               planeModel.getObjectByName( 'Cube_2_2_Body_0' ).material = detailsMaterial;
               planeModel.getObjectByName( 'Cube_2_3' ).material = detailsMaterial;
               planeModel.getObjectByName( 'Cube_2_3_Body_0' ).material = detailsMaterial;

               planeModel.getObjectByName( 'Cube_3' ).material = detailsMaterial;
               planeModel.getObjectByName( 'Cube_3__0' ).material = detailsMaterial;
               planeModel.getObjectByName( 'Cube_3_Body_0' ).material = bodyMaterial;
               planeModel.getObjectByName( 'Cube_3_Red_0' ).material = detailsMaterial;

					planeModel.getObjectByName( 'Cube_1_3_Glass_0' ).material = glassMaterial;
               planeModel.getObjectByName( 'Cube_3_Glass_0' ).material = glassMaterial;


               // shadow
					const mesh = new THREE.Mesh(
						new THREE.PlaneGeometry( 0.655 * 4, 1.3 * 4 ),
						new THREE.MeshBasicMaterial( {
							map: shadow, blending: THREE.MultiplyBlending, toneMapped: false, transparent: true
						} )
					);
					mesh.rotation.x = - Math.PI / 2;
					mesh.renderOrder = 2;
					planeModel.add( mesh );

					scene.add( planeModel );
            });

            loader.load('models/cartoon_plane.glb', function (gltf) {
               const animations = gltf.animations;

               console.log(`Found ${animations.length} animations:`);

               animations.forEach((animation, i) => {
                  console.log(`Animation ${i}: ${animation.name}`);
               });
            });


			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function render() {

				controls.update();

				const time = - performance.now() / 1000;
            //spin the propeller
            for (let i = 0; i < propeller.length; i++) {
               propeller[i].rotation.z = time * Math.PI * 2;
            } 
            //spin the plane to simulate turbulence
            targetRotation = Math.min(Math.sin(time) * Math.PI * 0.1, maxAngle);

            // Use lerp to smoothly transition between the current and target rotation
            planeRotation = THREE.MathUtils.lerp(planeRotation, targetRotation, 0.05);
         
            // apply the rotation to the plane
            for (let i = 0; i < planeBody.length; i++) {
               //restrict plane rotation
               planeBody[i].rotation.z = THREE.MathUtils.clamp(targetRotation, -Math.PI * 0.1, Math.PI * 0.1);
               //planeBody[i].rotation.z = THREE.MathUtils.clamp(planeRotation * Math.sin(time * 2), -Math.PI * 0.1, Math.PI * 0.1);
            }

				grid.position.z = - ( time ) % 1;

				renderer.render( scene, camera );

				stats.update();

			}

			init();

		</script>

	</body>
</html>